<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DataManager æµ‹è¯•</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        h1 {
            color: #333;
            border-bottom: 2px solid #4CAF50;
            padding-bottom: 10px;
        }
        .test-suite {
            background: white;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .test-suite h2 {
            margin-top: 0;
            color: #555;
            font-size: 1.1em;
        }
        .test-case {
            padding: 8px 12px;
            margin: 5px 0;
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .test-case.pass { background: #e8f5e9; color: #2e7d32; }
        .test-case.fail { background: #ffebee; color: #c62828; }
        .test-case .icon { font-size: 1.2em; }
        .summary {
            background: #333;
            color: white;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
        }
        .summary.all-pass { background: #4CAF50; }
        .summary.has-fail { background: #f44336; }
        .error-detail {
            font-size: 0.85em;
            color: #c62828;
            margin-left: 30px;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <h1>ğŸ§ª DataManager å•å…ƒæµ‹è¯•</h1>
    <div id="testResults">æ­£åœ¨è¿è¡Œæµ‹è¯•...</div>
    <div id="summary" class="summary"></div>

    <script src="../js/data/DataManager.js"></script>
    <script>
        // ç®€å•çš„æµ‹è¯•æ¡†æ¶
        const testResults = [];
        let currentSuite = '';

        function describe(name, fn) {
            currentSuite = name;
            fn();
        }

        async function test(name, fn) {
            try {
                await fn();
                testResults.push({ suite: currentSuite, name, pass: true });
            } catch (error) {
                testResults.push({ suite: currentSuite, name, pass: false, error: error.message });
            }
        }

        function expect(actual) {
            return {
                toBe(expected) {
                    if (actual !== expected) {
                        throw new Error(`Expected ${JSON.stringify(expected)}, got ${JSON.stringify(actual)}`);
                    }
                },
                toEqual(expected) {
                    if (JSON.stringify(actual) !== JSON.stringify(expected)) {
                        throw new Error(`Expected ${JSON.stringify(expected)}, got ${JSON.stringify(actual)}`);
                    }
                },
                toBeNull() {
                    if (actual !== null) {
                        throw new Error(`Expected null, got ${JSON.stringify(actual)}`);
                    }
                },
                toBeDefined() {
                    if (actual === undefined) {
                        throw new Error('Expected value to be defined');
                    }
                },
                toBeGreaterThan(expected) {
                    if (!(actual > expected)) {
                        throw new Error(`Expected ${actual} to be greater than ${expected}`);
                    }
                },
                toBeGreaterThanOrEqual(expected) {
                    if (!(actual >= expected)) {
                        throw new Error(`Expected ${actual} to be >= ${expected}`);
                    }
                },
                toContain(item) {
                    if (!actual.includes(item)) {
                        throw new Error(`Expected array to contain ${JSON.stringify(item)}`);
                    }
                },
                toHaveProperty(prop) {
                    if (!(prop in actual)) {
                        throw new Error(`Expected object to have property "${prop}"`);
                    }
                },
                toBeInstanceOf(cls) {
                    if (!(actual instanceof cls)) {
                        throw new Error(`Expected instance of ${cls.name}`);
                    }
                },
                toThrow(message) {
                    // ç”¨äºåŒæ­¥å‡½æ•°
                    let threw = false;
                    let errorMsg = '';
                    try {
                        actual();
                    } catch (e) {
                        threw = true;
                        errorMsg = e.message;
                    }
                    if (!threw) {
                        throw new Error('Expected function to throw');
                    }
                    if (message && !errorMsg.includes(message)) {
                        throw new Error(`Expected error message to include "${message}", got "${errorMsg}"`);
                    }
                }
            };
        }

        // å¼‚æ­¥expectçš„rejectsè¾…åŠ©
        expect.rejects = async function(promise) {
            return {
                async toThrow(message) {
                    let threw = false;
                    let errorMsg = '';
                    try {
                        await promise;
                    } catch (e) {
                        threw = true;
                        errorMsg = e.message;
                    }
                    if (!threw) {
                        throw new Error('Expected promise to reject');
                    }
                    if (message && !errorMsg.includes(message)) {
                        throw new Error(`Expected error message to include "${message}", got "${errorMsg}"`);
                    }
                }
            };
        };

        // ========================================
        // æµ‹è¯•ç”¨ä¾‹
        // ========================================
        async function runTests() {
            describe('æ„é€ å‡½æ•°', () => {
                test('åº”è¯¥æ­£ç¡®åˆå§‹åŒ–ç¼“å­˜', async () => {
                    const dm = new DataManager();
                    expect(dm._cache).toBeInstanceOf(Map);
                    expect(dm._cache.size).toBe(0);
                });

                test('åº”è¯¥åˆå§‹åŒ–æ¨¡æ‹Ÿæ•°æ®', async () => {
                    const dm = new DataManager();
                    expect(dm._subjects).toBeDefined();
                    expect(dm._subjects.length).toBeGreaterThan(0);
                    expect(dm._textbooks).toBeDefined();
                    expect(dm._chapters).toBeDefined();
                });
            });

            describe('getSubjects', () => {
                test('åº”è¯¥è¿”å›å­¦ç§‘åˆ—è¡¨', async () => {
                    const dm = new DataManager();
                    const subjects = await dm.getSubjects();
                    expect(Array.isArray(subjects)).toBe(true);
                    expect(subjects.length).toBe(3);
                });

                test('åº”è¯¥åŒ…å«è‹±è¯­ã€è¯­æ–‡ã€æ•°å­¦ä¸‰ä¸ªå­¦ç§‘', async () => {
                    const dm = new DataManager();
                    const subjects = await dm.getSubjects();
                    const subjectIds = subjects.map(s => s.id);
                    expect(subjectIds).toContain('english');
                    expect(subjectIds).toContain('chinese');
                    expect(subjectIds).toContain('math');
                });

                test('å­¦ç§‘åº”è¯¥æŒ‰orderæ’åº', async () => {
                    const dm = new DataManager();
                    const subjects = await dm.getSubjects();
                    for (let i = 1; i < subjects.length; i++) {
                        expect(subjects[i].order).toBeGreaterThanOrEqual(subjects[i-1].order);
                    }
                });

                test('å­¦ç§‘åº”è¯¥åŒ…å«å¿…è¦çš„å±æ€§', async () => {
                    const dm = new DataManager();
                    const subjects = await dm.getSubjects();
                    subjects.forEach(subject => {
                        expect(subject).toHaveProperty('id');
                        expect(subject).toHaveProperty('name');
                        expect(subject).toHaveProperty('icon');
                        expect(subject).toHaveProperty('color');
                        expect(subject).toHaveProperty('order');
                    });
                });

                test('åº”è¯¥ç¼“å­˜å­¦ç§‘æ•°æ®', async () => {
                    const dm = new DataManager();
                    await dm.getSubjects();
                    const cached = dm.getCachedData('subjects');
                    expect(cached).toBeDefined();
                    expect(cached.length).toBe(3);
                });
            });

            describe('getTextbooks', () => {
                test('åº”è¯¥è¿”å›æŒ‡å®šå­¦ç§‘çš„æ•™æåˆ—è¡¨', async () => {
                    const dm = new DataManager();
                    const textbooks = await dm.getTextbooks('english');
                    expect(Array.isArray(textbooks)).toBe(true);
                    expect(textbooks.length).toBeGreaterThan(0);
                    textbooks.forEach(t => {
                        expect(t.subjectId).toBe('english');
                    });
                });

                test('åº”è¯¥è¿”å›è¯­æ–‡æ•™æ', async () => {
                    const dm = new DataManager();
                    const textbooks = await dm.getTextbooks('chinese');
                    expect(textbooks.length).toBeGreaterThan(0);
                    textbooks.forEach(t => {
                        expect(t.subjectId).toBe('chinese');
                    });
                });

                test('åº”è¯¥è¿”å›æ•°å­¦æ•™æ', async () => {
                    const dm = new DataManager();
                    const textbooks = await dm.getTextbooks('math');
                    expect(textbooks.length).toBeGreaterThan(0);
                    textbooks.forEach(t => {
                        expect(t.subjectId).toBe('math');
                    });
                });

                test('æ•™æåº”è¯¥åŒ…å«å¿…è¦çš„å±æ€§', async () => {
                    const dm = new DataManager();
                    const textbooks = await dm.getTextbooks('english');
                    textbooks.forEach(textbook => {
                        expect(textbook).toHaveProperty('id');
                        expect(textbook).toHaveProperty('subjectId');
                        expect(textbook).toHaveProperty('name');
                        expect(textbook).toHaveProperty('publisher');
                        expect(textbook).toHaveProperty('grade');
                        expect(textbook).toHaveProperty('semester');
                        expect(textbook).toHaveProperty('coverImage');
                        expect(textbook).toHaveProperty('totalChapters');
                    });
                });

                test('ä¸å­˜åœ¨çš„å­¦ç§‘åº”è¯¥è¿”å›ç©ºæ•°ç»„', async () => {
                    const dm = new DataManager();
                    const textbooks = await dm.getTextbooks('nonexistent');
                    expect(Array.isArray(textbooks)).toBe(true);
                    expect(textbooks.length).toBe(0);
                });

                test('ç¼ºå°‘subjectIdåº”è¯¥æŠ›å‡ºé”™è¯¯', async () => {
                    const dm = new DataManager();
                    await (await expect.rejects(dm.getTextbooks())).toThrow('subjectId is required');
                    await (await expect.rejects(dm.getTextbooks(''))).toThrow('subjectId is required');
                });
            });

            describe('getChapters', () => {
                test('åº”è¯¥è¿”å›æŒ‡å®šæ•™æçš„ç« èŠ‚åˆ—è¡¨', async () => {
                    const dm = new DataManager();
                    const chapters = await dm.getChapters('english-pep-3-1');
                    expect(Array.isArray(chapters)).toBe(true);
                    expect(chapters.length).toBeGreaterThan(0);
                    chapters.forEach(c => {
                        expect(c.textbookId).toBe('english-pep-3-1');
                    });
                });

                test('ç« èŠ‚åº”è¯¥æŒ‰orderæ’åº', async () => {
                    const dm = new DataManager();
                    const chapters = await dm.getChapters('english-pep-3-1');
                    for (let i = 1; i < chapters.length; i++) {
                        expect(chapters[i].order).toBeGreaterThanOrEqual(chapters[i-1].order);
                    }
                });

                test('ç« èŠ‚åº”è¯¥åŒ…å«è¯¾ç¨‹åˆ—è¡¨', async () => {
                    const dm = new DataManager();
                    const chapters = await dm.getChapters('english-pep-3-1');
                    chapters.forEach(chapter => {
                        expect(chapter).toHaveProperty('lessons');
                        expect(Array.isArray(chapter.lessons)).toBe(true);
                    });
                });

                test('è¯¾ç¨‹åº”è¯¥åŒ…å«å¿…è¦çš„å±æ€§', async () => {
                    const dm = new DataManager();
                    const chapters = await dm.getChapters('english-pep-3-1');
                    chapters.forEach(chapter => {
                        chapter.lessons.forEach(lesson => {
                            expect(lesson).toHaveProperty('id');
                            expect(lesson).toHaveProperty('chapterId');
                            expect(lesson).toHaveProperty('name');
                            expect(lesson).toHaveProperty('order');
                            expect(lesson).toHaveProperty('totalPages');
                            expect(lesson).toHaveProperty('previewText');
                        });
                    });
                });

                test('ç¼ºå°‘textbookIdåº”è¯¥æŠ›å‡ºé”™è¯¯', async () => {
                    const dm = new DataManager();
                    await (await expect.rejects(dm.getChapters())).toThrow('textbookId is required');
                });

                test('ä¸å­˜åœ¨çš„æ•™æåº”è¯¥è¿”å›ç©ºæ•°ç»„', async () => {
                    const dm = new DataManager();
                    const chapters = await dm.getChapters('nonexistent');
                    expect(Array.isArray(chapters)).toBe(true);
                    expect(chapters.length).toBe(0);
                });
            });

            describe('getPageContent', () => {
                test('åº”è¯¥è¿”å›é¡µé¢å†…å®¹', async () => {
                    const dm = new DataManager();
                    const content = await dm.getPageContent('english-pep-3-1-unit1-lesson1', 1);
                    expect(content).toBeDefined();
                    expect(content.lessonId).toBe('english-pep-3-1-unit1-lesson1');
                    expect(content.pageNumber).toBe(1);
                });

                test('é¡µé¢å†…å®¹åº”è¯¥åŒ…å«å¯ç‚¹è¯»å…ƒç´ ', async () => {
                    const dm = new DataManager();
                    const content = await dm.getPageContent('english-pep-3-1-unit1-lesson1', 1);
                    expect(content).toHaveProperty('clickableElements');
                    expect(Array.isArray(content.clickableElements)).toBe(true);
                    expect(content.clickableElements.length).toBeGreaterThan(0);
                });

                test('å¯ç‚¹è¯»å…ƒç´ åº”è¯¥åŒ…å«å¿…è¦çš„å±æ€§', async () => {
                    const dm = new DataManager();
                    const content = await dm.getPageContent('english-pep-3-1-unit1-lesson1', 1);
                    content.clickableElements.forEach(elem => {
                        expect(elem).toHaveProperty('id');
                        expect(elem).toHaveProperty('type');
                        expect(elem).toHaveProperty('content');
                        expect(elem).toHaveProperty('audioId');
                        expect(elem).toHaveProperty('position');
                        expect(elem.position).toHaveProperty('x');
                        expect(elem.position).toHaveProperty('y');
                        expect(elem.position).toHaveProperty('width');
                        expect(elem.position).toHaveProperty('height');
                    });
                });

                test('ä¸å­˜åœ¨çš„é¡µé¢åº”è¯¥è¿”å›é»˜è®¤ç©ºå†…å®¹', async () => {
                    const dm = new DataManager();
                    const content = await dm.getPageContent('nonexistent-lesson', 1);
                    expect(content).toBeDefined();
                    expect(content.lessonId).toBe('nonexistent-lesson');
                    expect(content.pageNumber).toBe(1);
                    expect(content.clickableElements.length).toBe(0);
                });

                test('ç¼ºå°‘lessonIdåº”è¯¥æŠ›å‡ºé”™è¯¯', async () => {
                    const dm = new DataManager();
                    await (await expect.rejects(dm.getPageContent('', 1))).toThrow('lessonId is required');
                });

                test('æ— æ•ˆçš„pageNumberåº”è¯¥æŠ›å‡ºé”™è¯¯', async () => {
                    const dm = new DataManager();
                    await (await expect.rejects(dm.getPageContent('lesson1', 0))).toThrow('pageNumber must be a positive number');
                    await (await expect.rejects(dm.getPageContent('lesson1', -1))).toThrow('pageNumber must be a positive number');
                });
            });

            describe('getAudioUrl', () => {
                test('åº”è¯¥è¿”å›æ­£ç¡®çš„éŸ³é¢‘URL', async () => {
                    const dm = new DataManager();
                    const url = dm.getAudioUrl('audio-hello', 'voice-female');
                    expect(url).toBe('assets/audio/voice-female/audio-hello.mp3');
                });

                test('ç¼ºå°‘voiceIdåº”è¯¥ä½¿ç”¨é»˜è®¤éŸ³è‰²', async () => {
                    const dm = new DataManager();
                    const url = dm.getAudioUrl('audio-hello');
                    expect(url).toBe('assets/audio/voice-female/audio-hello.mp3');
                });

                test('ç¼ºå°‘contentIdåº”è¯¥æŠ›å‡ºé”™è¯¯', async () => {
                    const dm = new DataManager();
                    expect(() => dm.getAudioUrl()).toThrow('contentId is required');
                    expect(() => dm.getAudioUrl('')).toThrow('contentId is required');
                });
            });

            describe('ç¼“å­˜æœºåˆ¶', () => {
                test('cacheDataåº”è¯¥æ­£ç¡®å­˜å‚¨æ•°æ®', async () => {
                    const dm = new DataManager();
                    const testData = { foo: 'bar' };
                    dm.cacheData('test-key', testData);
                    const cached = dm.getCachedData('test-key');
                    expect(cached.foo).toBe('bar');
                });

                test('cacheDataç¼ºå°‘keyåº”è¯¥æŠ›å‡ºé”™è¯¯', async () => {
                    const dm = new DataManager();
                    expect(() => dm.cacheData('', { data: 'test' })).toThrow('Cache key is required');
                });

                test('getCachedDataå¯¹äºä¸å­˜åœ¨çš„keyåº”è¯¥è¿”å›null', async () => {
                    const dm = new DataManager();
                    const result = dm.getCachedData('nonexistent-key');
                    expect(result).toBeNull();
                });

                test('getCachedDataå¯¹äºç©ºkeyåº”è¯¥è¿”å›null', async () => {
                    const dm = new DataManager();
                    const result = dm.getCachedData('');
                    expect(result).toBeNull();
                });

                test('clearCacheåº”è¯¥æ¸…é™¤æŒ‡å®šç¼“å­˜', async () => {
                    const dm = new DataManager();
                    dm.cacheData('test-key', { data: 'test' });
                    expect(dm.getCachedData('test-key')).toBeDefined();
                    dm.clearCache('test-key');
                    expect(dm.getCachedData('test-key')).toBeNull();
                });

                test('clearAllCacheåº”è¯¥æ¸…é™¤æ‰€æœ‰ç¼“å­˜', async () => {
                    const dm = new DataManager();
                    dm.cacheData('key1', { data: 'test1' });
                    dm.cacheData('key2', { data: 'test2' });
                    dm.clearAllCache();
                    expect(dm.getCachedData('key1')).toBeNull();
                    expect(dm.getCachedData('key2')).toBeNull();
                });

                test('getCacheStatsåº”è¯¥è¿”å›ç¼“å­˜ç»Ÿè®¡', async () => {
                    const dm = new DataManager();
                    dm.cacheData('key1', { data: 'test1' });
                    dm.cacheData('key2', { data: 'test2' });
                    const stats = dm.getCacheStats();
                    expect(stats.size).toBe(2);
                    expect(stats.keys).toContain('key1');
                    expect(stats.keys).toContain('key2');
                });

                test('è¿‡æœŸçš„ç¼“å­˜åº”è¯¥è¿”å›null', async () => {
                    const dm = new DataManager();
                    dm.cacheData('test-key', { data: 'test' });
                    // ä½¿ç”¨å¾ˆçŸ­çš„maxAgeæ¥æµ‹è¯•è¿‡æœŸ
                    const result = dm.getCachedData('test-key', 0);
                    expect(result).toBeNull();
                });
            });

            describe('è¾…åŠ©æ–¹æ³•', () => {
                test('hasSubjectåº”è¯¥æ­£ç¡®æ£€æŸ¥å­¦ç§‘æ˜¯å¦å­˜åœ¨', async () => {
                    const dm = new DataManager();
                    expect(dm.hasSubject('english')).toBe(true);
                    expect(dm.hasSubject('chinese')).toBe(true);
                    expect(dm.hasSubject('math')).toBe(true);
                    expect(dm.hasSubject('nonexistent')).toBe(false);
                });

                test('hasTextbookåº”è¯¥æ­£ç¡®æ£€æŸ¥æ•™ææ˜¯å¦å­˜åœ¨', async () => {
                    const dm = new DataManager();
                    expect(dm.hasTextbook('english-pep-3-1')).toBe(true);
                    expect(dm.hasTextbook('chinese-rj-3-1')).toBe(true);
                    expect(dm.hasTextbook('nonexistent')).toBe(false);
                });
            });

            describe('getLesson', () => {
                test('åº”è¯¥è¿”å›è¯¾ç¨‹ä¿¡æ¯', async () => {
                    const dm = new DataManager();
                    const lesson = await dm.getLesson('english-pep-3-1-unit1-lesson1');
                    expect(lesson).toBeDefined();
                    expect(lesson.id).toBe('english-pep-3-1-unit1-lesson1');
                    expect(lesson.name).toBe("Part A Let's talk");
                });

                test('ä¸å­˜åœ¨çš„è¯¾ç¨‹åº”è¯¥è¿”å›null', async () => {
                    const dm = new DataManager();
                    const lesson = await dm.getLesson('nonexistent');
                    expect(lesson).toBeNull();
                });

                test('ç©ºlessonIdåº”è¯¥è¿”å›null', async () => {
                    const dm = new DataManager();
                    const lesson = await dm.getLesson('');
                    expect(lesson).toBeNull();
                });
            });

            describe('getVoices', () => {
                test('åº”è¯¥è¿”å›éŸ³è‰²åˆ—è¡¨', async () => {
                    const dm = new DataManager();
                    const voices = await dm.getVoices();
                    expect(Array.isArray(voices)).toBe(true);
                    expect(voices.length).toBe(3);
                });

                test('åº”è¯¥åŒ…å«ç”·å£°ã€å¥³å£°ã€ç«¥å£°', async () => {
                    const dm = new DataManager();
                    const voices = await dm.getVoices();
                    const types = voices.map(v => v.type);
                    expect(types).toContain('male');
                    expect(types).toContain('female');
                    expect(types).toContain('child');
                });

                test('éŸ³è‰²åº”è¯¥åŒ…å«å¿…è¦çš„å±æ€§', async () => {
                    const dm = new DataManager();
                    const voices = await dm.getVoices();
                    voices.forEach(voice => {
                        expect(voice).toHaveProperty('id');
                        expect(voice).toHaveProperty('name');
                        expect(voice).toHaveProperty('type');
                        expect(voice).toHaveProperty('previewAudioUrl');
                        expect(voice).toHaveProperty('description');
                    });
                });
            });

            describe('dataManagerå•ä¾‹', () => {
                test('åº”è¯¥å¯¼å‡ºå•ä¾‹å®ä¾‹', async () => {
                    expect(dataManager).toBeDefined();
                    expect(dataManager).toBeInstanceOf(DataManager);
                });
            });

            // æ¸²æŸ“ç»“æœ
            renderResults();
        }

        // ========================================
        // æ¸²æŸ“æµ‹è¯•ç»“æœ
        // ========================================
        function renderResults() {
            const container = document.getElementById('testResults');
            const summaryEl = document.getElementById('summary');
            
            // æŒ‰æµ‹è¯•å¥—ä»¶åˆ†ç»„
            const suites = {};
            testResults.forEach(result => {
                if (!suites[result.suite]) {
                    suites[result.suite] = [];
                }
                suites[result.suite].push(result);
            });

            // æ¸²æŸ“æ¯ä¸ªæµ‹è¯•å¥—ä»¶
            let html = '';
            for (const [suiteName, tests] of Object.entries(suites)) {
                html += `<div class="test-suite">
                    <h2>${suiteName}</h2>`;
                
                tests.forEach(test => {
                    const icon = test.pass ? 'âœ…' : 'âŒ';
                    const className = test.pass ? 'pass' : 'fail';
                    html += `<div class="test-case ${className}">
                        <span class="icon">${icon}</span>
                        <span>${test.name}</span>
                    </div>`;
                    if (!test.pass && test.error) {
                        html += `<div class="error-detail">${test.error}</div>`;
                    }
                });
                
                html += '</div>';
            }
            
            container.innerHTML = html;

            // æ¸²æŸ“æ‘˜è¦
            const passed = testResults.filter(r => r.pass).length;
            const failed = testResults.filter(r => !r.pass).length;
            const total = testResults.length;
            
            summaryEl.className = `summary ${failed === 0 ? 'all-pass' : 'has-fail'}`;
            summaryEl.innerHTML = `
                <strong>æµ‹è¯•ç»“æœ:</strong> ${passed}/${total} é€šè¿‡
                ${failed > 0 ? ` | ${failed} å¤±è´¥` : ' | å…¨éƒ¨é€šè¿‡ ğŸ‰'}
            `;
        }

        // è¿è¡Œæµ‹è¯•
        runTests();
    </script>
</body>
</html>
